<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Attention restoration experiment, with Adaptive DSB and Visual Search</title>
  <!--  Load jsPsych CSS -->
  <link href="https://unpkg.com/jspsych@7.3.3/css/jspsych.css" rel="stylesheet" type="text/css" />
  <style>
     body {
            background-color: #808070;
        }
    /* Custom styles for better visibility and responsiveness */
    .progress-container {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 10px;
      z-index: 1000;
    }

    .progress-bar {
      height: 100%;
      background-color: #4CAF50;
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .experiment-text {
      color: white;
      font-size: 24 px;
      /* adjust as needed, or update with pixelsperUnit*/
      text-align: center;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .experiment-images {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            /* uses viewport height or width */
            background-color: #808070;
    }
    .search-target {
      font-weight: bold;
      text-shadow: 0 0 3px white;
    }
    .standard-button {
      font-size: 20px;
      padding: 15px 30px;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }
    @media (max-width: 768px) {
      .search-item {
        font-size: 4vw !important;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      .search-item {
        font-size: 3vw !important;
      }
    }

    @media (min-width: 1025px) {
      .search-item {
        font-size: 2vw !important;
      }
    }
  </style>
<!-- add to work with JATOS -->
<script src="jatos.js"></script>
</head>

<body>
  <!-- Experiment container -->
  <div id="jspsych-experiment"></div>
  <!-- Load jsPsych -->
  <script src="https://unpkg.com/jspsych@7.3.3"></script>
  <!-- <script src= "https://unpkg.com/jspsych@7.3.3/dist/index.browser.min.js"></script> -->
  <!-- Load the html-keyboard-response plugin -->
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.2"></script>
  <!-- Load the html-button-response plugin -->
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.2"></script>
  <script src="https://unpkg.com/@jspsych/plugin-resize@1.0.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-likert@1.1.2"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@1.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.2"></script>

  

  <script>

    //Initialize JsPsych    
    const jsPsych = initJsPsych({
        display_element: 'jspsych-experiment',
        on_finish: function () {
          console.log("Experiment finished!");
          //retrieve data
          const data = jsPsych.data.get();
          // Generate CSV and JSON data
          const csvData = data.csv();
          // Added JSON data for JATOS GUI
          const jsonData = data.json();

          // if not in jatos, show the result on screen.
          if (typeof jatos === 'undefined') {
            //dev mode, local, (prob running in macbook/offline), show data on screen.
            jsPsych.data.displayData(csvData);
          } else { // upload to jatos and redirect afterwards.

            //create and upload csv blob first:
            const csvBlob = new Blob([csvData], { type: 'text/csv' });
            jatos.uploadResultFile(csvBlob, "experiment-data.csv", function () {
              console.log("File upload successful");
              // Submit JSON data using callback approach
              console.log("Submitting JSON data to JATOS...");
              
              jatos.submitResultData(jsonData, function () {
                console.log("JSON data submitted successfully");
                // Get participant ID from URL (with defensive checks)
                var pp_id = "DEFAULT_ID";
                if (jatos.urlQueryParameters && jatos.urlQueryParameters.SONA_ID) {
                  pp_id = jatos.urlQueryParameters.SONA_ID;
                  debugLog(`SONA ID is ${pp_id}`);
                } else {
                  debugLog(`SONA ID not found, using default`);
                }
                // Create completion URL for receiving credit
                
                var completion_url = "https://uts-psych.sona-systems.com/webstudy_credit.aspx?experiment_id=98&credit_token=e9679869caf24c33adb4f8cda89b1dcd&survey_code" + pp_id;
                
                if (pp_id === "DEFAULT_ID") {
                  completion_url = "http://127.0.0.1:9000/jatos/4/11/results";
                }
                // Only redirect after both file upload AND data submission
                jatos.endStudyAndRedirect(completion_url);
              },
              );
            }
            );
          }
        }
      });
      
    // a better function for debugging: shorthand for console.log()
    function debugLog(message) {
      console.log(`[${new Date().toISOString()}] ${message}`);
    }
    
    let pixelsPerUnit= 150;// default to start with
    
    // Set static and global experiment parameters
    let experimentParams = {
      // Block structure
      nBlocks: 4, // must be divisible by 2 (corresponding to search difficulties.)
      nTrials: 9, // per block, note that this is divisible by 3 (per image types), and we will add one no-image per block.
      nPracticeTrials: 2, // this n is reps of both types -same as exp, absent the images.

      // Visual search parameters
      searchDifficulty: 1, //[1 or 2], easy or hard, updated dynamically below.      
      minDistancePercentage: 1, // min dist between elements.
      containerPaddingPercentage: 10, // reduced to avoid stack overflow.
      nTargs: 30,
      searchTrialDuration: 2500, // ms per search. 
      nRepeats: 10, // how many reps per vis search sequence?

      // DSB parameters
      // DSBconds: [4,6,8], //span lengths.

      // now just using the max.
      maxDigitSpan: 8, //(n-1)
      digitDuration: 1000, //ms

      // Image parameters
      nImages: 9,
      imgDuration: 15000, //ms 

      // Attention check parameters
      attentionCheckFrequency: 0.1, // 10% chance per trial

      // also add some dynamic fields which we will update and save from
      dyn_trialidx:0, //count in exp
      dyn_trial:0, //count in block
      dyn_block:0, //
      dyn_VSD: 1, // visual search difficulty
      dyn_VS_propcorrect: 0, //proportion of vis search targets found. 
      dyn_VS_meanRT: 0,//visual search mean RT
      dyn_DSBpre_propcorrect: 0, //the  proportion of sequences correct.
      dyn_DSBpre_digitaccuracy: 0,//the number of digits correct.
      dyn_DSBpre_maxspan: 0, // the max span correct.
      dyn_DSBpre_rt: null, // 
      dyn_imageID: 0, // image index/identifier.
      dyn_DSBpost_propcorrect: 0, //the  proportion of sequences correct.      
      dyn_DSBpost_digitaccuracy: 0, // the max span correct. 
      dyn_DSBpost_maxspan: 0,//the number of digits correct.
      dyn_DSBpost_rt: null, 

    };

    // Message Components
    const messages = {
      Welcome: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `<div class="experiment-text" style= "font-size: ${24 * pixelsPerUnit / 150}px;">
          Welcome !! <br><br>
          On the next screen you will be shown the Participant Information Sheet and Consent Form. <br><br> Please
          read both carefully before confirming your participation.</div>`,
        choices: ["continue"],
        button_html: '<button class="standard-button">%choice%</button>',        
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `welcome_msg`;
          data.task ='wecome';
        }
      },
      
      PISdoc: {
        type: jsPsychHtmlButtonResponse,
        stimulus: function () {
          return `
          <div style="display: flex; flex-direction: column; align-items: center; width: 100%; padding: 0;">
          <div style="width: 100vh; height: 80vh; border: 1px solid #ccc; background-color: white; margin: 40 auto; overflow: hidden;">
          <iframe src="docs/PIS.pdf#view=FitH" style="width: 100%; height: 90%; border: none;"></iframe>
          </div>
          </div>
          `;
        },
        choices: [`Click here to confirm consent and continue. Or close this browser window to end the study.`],
        button_html: '<button class="standard-button">%choice%</button>',
        
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `PISdoc`;
          data.task= 'PIS';
        }

      },
      Debriefdoc: {
        type: jsPsychHtmlButtonResponse,
        stimulus: function () {
          return `            
            <div style="display: flex; flex-direction: column; align-items: center; width: 100%; padding: 0;">
                <div style="width: 100vh; height: 80vh; border: 1px solid #ccc; background-color: white; margin: 40 auto; overflow: hidden;">
                    <iframe src="docs/debrief.pdf#view=FitH" style="width: 100%; height: 90%; border: none;"></iframe>
                </div>                        
            </div>
          `;
        },
        choices: [`Click here to end the experiment and receive course credit.`],
        button_html: '<button class="standard-button">%choice%</button>',
        
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `debrief`;
          data.task= 'debrief' ;
        }

      },
      pracInstructions: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `<div style= "font-size: ${24 * pixelsPerUnit / 150}px; color: white; 
        position: absolute;
         top: 50%;left: 50%; transform: translate(-50%, -50%)">        

            <br>Welcome to the experiment.<br> 
            Please read the instructions carefully.<br>
            There are two task types.<br><br>
            In the visual search task:<br>
            You must search the screen for either a red <font color = "red">"T" </font>
            or blue <font color = "blue"> "O" </font> hidden among red <font color = "red"> "X"s </font>.
            <br><br> In the digit task:<br> You must recall a list of numbers in reverse order. </div>
        `,
        choices: ["Let's practice!"],
        button_html:  '<button class="standard-button">%choice%</button>',
      },
      expInstructions: {
        timeline: [
          {
            type: jsPsychHtmlButtonResponse,
            stimulus: function () {
              const slideNumber = jsPsych.timelineVariable('slideNum');
              return `
                        <div class = "experiment-images">                      
                    <img src="instruction-images/expInstructions/Slide${slideNumber}.jpeg" 
                    alt="Experiment Instructions" > 
                    </div>`;
            },
            choices: ["Continue"],
            button_html: '<button class="standard-button">%choice%</button>',
            
            on_finish: function (data) {
              //replace stim with simple placeholder
              data.stimulus = `expInstruc`;
              data.task = `expIntructions`;

            }
          }
        ],
        timeline_variables: [
          { slideNum: 1 },
          { slideNum: 2 },
          { slideNum: 3 },
          { slideNum: 4 },
          { slideNum: 5 },
          { slideNum: 6 },
          { slideNum: 7 }
        ]
      },

      startMain: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `<div class="experiment-text" style= "font-size: ${24 * pixelsPerUnit / 150}px;">
          You are now ready to start the main experiment </div>`,
        choices: ['Continue'],
        button_html:  '<button class="standard-button">%choice%</button>',
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `startMain`;
          data.task = `startMain`;
        } 
      },
      getReady: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `<div class="experiment-text" style= "font-size: ${24 * pixelsPerUnit / 150}px;">
          Get ready for the next trial </div>`,
        choices: ['Continue'],
        button_html:  '<button class="standard-button">%choice%</button>',
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `getReady`;
          data.task = `getReady`;
        } 
      },

      VisSearchInstructions: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <div style = "font-size: ${24 * pixelsPerUnit / 150}px; color: white; 
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);">
           On the next screen, you must search for and CLICK ON either a red</span> 
            <span style="color: red;">"T"</span> or blue <span style="color: blue;">"O"</span><br>
             hidden among red <span style="color: red;">"X"</span>s. </div>
        `,
        choices: ['Ready'],
        button_html:  '<button class="standard-button">%choice%</button>',
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `VS_instruct`;
          data.task = `VS_instruct`;
        } 
      },

      DSBinstructions: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `<div style= "font-size: ${24 * pixelsPerUnit / 150}px; color: white; 
        position: absolute;
         top: 50%;left: 50%; transform: translate(-50%, -50%)"> 
            <br><br>On the next screen, you will be shown a sequence of numbers.<br><br>
            <br><br>
            Your task is to remember the numbers in reverse order.<br>
            e.g. if you see <span style="color: blue;">1, 2, 3, 4</span>,<br>
            respond: <span style="color: red;">4, 3, 2, 1<br><br><br><br></span>
          </div>
        `,
        choices: ['Ready'],
        button_html:  '<button class="standard-button">%choice%</button>',
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `DSB_instruct`;
          data.task = `DSB_instruct`;
        } 
      },
      imageInstructions: {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <div class="experiment-text" style= "font-size: ${24 * pixelsPerUnit / 150}px;">
            <br><br>On the next screen, you will be shown an image of nature.<br><br>
            Please view this image, the experiment will resume shortly.
          </div>
        `,
        choices: ['Ready'],
        button_html:  '<button class="standard-button">%choice%</button>',
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `image_instruct`;
          data.task = `image_instruct`;
        } 
      },

    };

    const demographicsForm = {
        type: jsPsychSurveyHtmlForm,
        preamble: '<div style="color: white; text-align: center;"><h2>Demographic Information</h2><p>Please provide the following information:</p></div>',
        html: `
        <div style="display: flex; flex-direction: column; align-items: center; color: white;">
            <div style="margin-bottom: 20px; text-align: left; width: 80%; max-width: 500px;">
                <label for="age" style="display: block; margin-bottom: 5px;">What is your age (in years)?:</label>
                <input type="number" id="age" name="age" min="18" max="100" required style="width: 100%; padding: 8px; font-size: 16px;">
            </div>
            
            <div style="margin-bottom: 20px; text-align: left; width: 80%; max-width: 500px;">
                <label for="gender" style="display: block; margin-bottom: 5px;">What is your gender?</label>
                <select id="gender" name="gender" required style="width: 100%; padding: 8px; font-size: 16px;">
                    <option value="" selected disabled>Please select</option>
                    <option value="male">Male</option>
                    <option value="female">Female</option>
                    <option value="non-binary">Non-binary</option>
                    <option value="other">Other</option>
                    <option value="prefer_not_to_say">Prefer not to say</option>
                </select>
            </div>
        </div>
    `,
        button_label: 'Continue',
        data: {
            task: 'demographics'
        },
        on_finish: function (data) {
            // Log the demographic data
            console.log("Demographics collected:", data.response);

            // Add to global jsPsych data properties
            jsPsych.data.addProperties({
                participant_age: data.response.age,
                participant_gender: data.response.gender
            });
        }
    };

    const feedbackTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: function () {
        const lastRecall = jsPsych.data.get().last(1).values()[0];
        return lastRecall.is_correct
          ? "<p style='color:green;'>Correct!</p><p>Good job!</p>"
          : "<p style='color:red;'>Incorrect.</p><p>Try to recall in the reversed order.</p>";
      },
      choices: ['Continue'],
      on_finish: function (data) {
          //replace stim with simple placeholder          
          data.task = `feedback`;
        } 
    };

    // survey variable 
  
    const PRSpreamble={
      type: jsPsychHtmlButtonResponse,
      stimulus: ` <div class = "experiment-text"; style= "font-size: ${24 * pixelsPerUnit / 150}px;">
      We are interested in how you experienced this environment. <br>
      To help us understand your experience,<br>
      we have provided the following statements for you to respond to.<br> <br>
      Please read carefully, then ask yourself: <br>
      "how much does this statement apply to my experience here?". <br>
      To indicate your answer choose one number from the rating scale beside each statement.<br><br>
      So, for example, if you think the statement does not apply to you at all, choose "0" (not at all).<br>
      If you think it applies completely, you would select "10" (complete agreement).<br>
      </div>`,
      choices: ['Continue'],
      button_html: '<button class="standard-button">%choice%</button>',
      on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `PRS_preamble`;
          data.task = `PRS_preamble`;
        } 
    };

    //this function creates the labels used below
    function createLabelSet() {
        const labels = [];

        // Add the "0(not at all)" label
        labels.push("<div style='color:white; text-align:center;'>0<br>(not at all)</div>");

        // Add labels 1-4
        for (let i = 1; i <= 4; i++) {
          labels.push(`<div style='color:white; text-align:center;'>${i}</div>`);
        }

        // Add the "5(moderate agreement)" label
        labels.push("<div style='color:white; text-align:center;'>5<br>(moderate agreement)</div>");

        // Add labels 6-9
        for (let i = 6; i <= 9; i++) {
          labels.push(`<div style='color:white; text-align:center;'>${i}</div>`);
        }

        // Add the "10(complete agreement)" label
        labels.push("<div style='color:white; text-align:center;'>10<br>(complete agreement)</div>");

        return labels;
      }
    
    function createPRS11(imgNumber) {
      return {
        type: jsPsychSurveyLikert,
        preamble: `<div style="text-align: center; margin-bottom: 30px;">
          <img src="images/set_1/photo_${imgNumber}.jpg" style="max-width: 80%; max-height: 50vh; border-radius: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
          <div style="color: white; font-size: ${24 * pixelsPerUnit / 150}px;">
          <p>Please rate how much each statement applies to your experience of this image:</p>
          </div>
          </div>`,
        questions: [
          { prompt: "Places like that are fascinating", name: 'FA_12', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "In places like this my attention is drawn to many interesting things", name: 'FA_7', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "In places like this it is hard to be bored", name: 'FA_11', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "Places like this are a refuge from nuisances", name: 'BA_1', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "To get away from things that usually demand my attention I like to go to places like this", name: 'BA_5', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "To stop thinking about the things that I must get done I like to go to places like this", name: 'BA_4', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "There is a clear order in the physical arrangement of places like this", name: 'COH_15rev', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "In places like this it is easier to see how things are organised", name: 'COH_26', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "In places like this everything seems to have its proper place", name: 'newitem', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "That place is large enough to allow exploration in many directions", name: 'FA_10', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
          { prompt: "In places like that there are few boundaries to limit my possibility for moving about", name: 'X', labels: ["0<br>(not at all)", "1", "2", "3", "4", "5<br>(moderate agreement)", "6", "7", "8", "9", "10<br>(complete agreement)"] },
        ],
        randomize_question_order: false,
        scale_width: 500,
        button_label: 'Continue',
        data: {
          task: 'PRS-11'          
        },
        // Add custom styling for white text
        on_load: function () {
          // Make all text elements white for dark background
          document.querySelectorAll('.jspsych-survey-likert-statement').forEach(element => {
            element.style.color = 'white';
          });
          // Add CSS to make the survey labels white and centered
          const styleElement = document.createElement('style');
          styleElement.textContent = `
          .jspsych-survey-likert-opt-label {
            color: white !important;
            text-align: center !important;
          }
        `;
          document.head.appendChild(styleElement);
        },
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `PRS11`;          
        } 
      };
    }
    function createRateAIlikelihood(imgNumber,setN) {
      return {
        type: jsPsychSurveyLikert,
        preamble: `<div style="text-align: center; margin-bottom: 30px;">
          <img src="images/set_${setN}/photo_${imgNumber}.jpg" style="max-width: 80%; max-height: 50vh; border-radius: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
          <div style="color: white; font-size: ${24 * pixelsPerUnit / 150}px;">          
          </div>
          </div>`,
        questions: [
          { prompt: "Please rate how likely it is that this image was artificially generated:", 
            name: 'rateAI', labels: 
            ["Certainly not", "Unlikely", "Unsure", "Likely", "Certainly"],
            required: true,
           },
          
        ],
        randomize_question_order: false,
        scale_width: 500,
        button_label: 'Continue',
        data: {
          task: 'rate-AI'  ,
          image_id: imgNumber,        
          iamge_set: setN
        },
        // Add custom styling for white text
        on_load: function () {
          // Make all text elements white for dark background
          document.querySelectorAll('.jspsych-survey-likert-statement').forEach(element => {
            element.style.color = 'white';
          });
          // Add CSS to make the survey labels white and centered
          const styleElement = document.createElement('style');
          styleElement.textContent = `
          .jspsych-survey-likert-opt-label {
            color: white !important;
            text-align: center !important;
          }
        `;
          document.head.appendChild(styleElement);
        },
        on_finish: function (data) {
          //replace stim with simple placeholder
          data.stimulus = `rate-AI`;          
        } 
      };
    }


    // Preload images
    const preloadImages = {
      type: jsPsychPreload,
      images: Array.from({ length: experimentParams.nImages }, (_, i) => `images/set_1/photo_${i + 1}.jpg`),
      message: 'Loading experiment resources...',
      show_progress_bar: true,
      continue_after_error: true,
      error_message: 'Failed to load some images. The experiment will continue, but you may experience some delays.',
      on_error: function (file) {
        console.error(`Failed to load: ${file}`);
      }
    };


    // Attention check trial
    function createAttentionCheck() {
      const targetButtonIndex = Math.floor(Math.random() * 3);
      const buttonLabels = ['Stop', 'Continue', 'Next'];
      const targetButtonLabel = buttonLabels[targetButtonIndex]; 

      return {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <div style="text-align: center;">
            <p>Attention Check: Please select the button labeled "${targetButtonLabel}"</p>
          </div>
        `,
        choices: ['Stop', 'Continue', 'Next'],
        on_finish: function (data) {
          
          data.attention_check_correct = data.response === targetButtonIndex;
          data.stimulus = 'attncheck';
          data.task = 'attncheck'
          data.target_button= targetButtonLabel;
        }
      };
    }



    function callSingleImageTrial(imgID) {
      let stimulusContent;
      if (imgID===10) { // show only a fixation cross
        stimulusContent= `
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
          <div style="font-size: ${24 * pixelsPerUnit / 150}px; color: white;">+</p>
            </div>`;  
      } else {
        
        stimulusContent = `
          <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90vw; height: 90vh; display: flex; justify-content: center; align-items: center; overflow: hidden;">
          <img src="images/set_1/photo_${imgID}.jpg" 
          style="max-width: 100%; max-height: 100%; object-fit: contain;">
          </div>`;
      }
      
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: stimulusContent,
        choices: "NO_KEYS", // No response required
        trial_duration: experimentParams.imgDuration, // Hold 
        on_load: () => {
          console.log("Static scene loaded.");
        },
        on_finish: function (data) {
          data.stimulus = `img${imgID}`;        
          data.task = `img${imgID}`;
          experimentParams.dyn_imageID = imgID;
          // store some information about the iamges. currrently hardcoded:
          // photo 1,2,3 = low,med,high, (real,ai,ai).
          // photo 4,5,6 = low,med,high, (ai,real,ai).
          // photo 7,8,9= low,med,high (ai,ai,real).  
          // photo 10= fixation cross
          // 1,4,7 = low, 2,5,8 = med, 3,6,9 = high.
            // Store vegetation level and image type
          if (imgID >= 1 && imgID <= 9) {
          // Vegetation level: 1,4,7=low(1); 2,5,8=medium(2); 3,6,9=high(3)
          if (imgID === 1 || imgID === 4 || imgID === 7) {
            data.vegetationLevel = 1; // Low
          } else if (imgID === 2 || imgID === 5 || imgID === 8) {
            data.vegetationLevel = 2; // Medium
          } else if (imgID === 3 || imgID === 6 || imgID === 9) {
            data.vegetationLevel = 3; // High
          }
          
            // Image type: 1,5,9=real(1); others=AI(2)
            if (imgID === 1 || imgID === 5 || imgID === 9) {
              data.imageType = 1; // Real
            } else {
              data.imageType = 2; // AI
            }
          } else if (imgID === 10) {
            // Fixation cross
            data.vegetationLevel = null;
            data.imageType = null;
          }
          }
        
      }
    }

    function generateGridPositions(n, containerWidth, containerHeight, containerPaddingPercentage) {
      const positions = [];

      // Calculate padding in pixels
      const padding = Math.min(containerWidth, containerHeight) * (containerPaddingPercentage / 100);
      // Define grid size
      const gridSize = Math.ceil(Math.sqrt(n)); // Number of rows and columns in the grid
      const cellWidth = (containerWidth - 2 * padding) / gridSize;
      const cellHeight = (containerHeight - 2 * padding) / gridSize;

      // Generate all possible grid cells
      const gridCells = [];
      for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
          gridCells.push({ row, col });
        }
      }

      // Shuffle the grid cells to randomize their order
      for (let i = gridCells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [gridCells[i], gridCells[j]] = [gridCells[j], gridCells[i]];
      }

      // Select the first `n` grid cells
      for (let i = 0; i < n; i++) {
        const cell = gridCells[i];

        // Calculate center of cells
        const x = padding + (cell.col + 0.5) * cellWidth; // Center of the cell
        const y = padding + (cell.row + 0.5) * cellHeight; // Center of the cell

        // Add jitter (small offsets)
        const jitterX = (Math.random() - 0.5) * cellWidth * 0.6; // ±30% of cell
        const jitterY = (Math.random() - 0.5) * cellHeight * 0.6; // ±30% of cell

        // Convert to percentages
        const xPercent = ((x + jitterX) / containerWidth) * 100;
        const yPercent = ((y + jitterY) / containerHeight) * 100;

        positions.push({ x: xPercent, y: yPercent });
      }

      return positions;
    }

function createVisualSearchTrial(searchDifficulty) {
    const containerWidth = window.innerWidth * 0.6;
    const containerHeight = window.innerHeight * 0.6;
    const itemSize = pixelsPerUnit* 0.5; // Adjusts to relevant size
    

    return {
      type: jsPsychHtmlButtonResponse,
      stimulus: () => {
        const positions = generateGridPositions(
          experimentParams.nTargs + 1,
          containerWidth,
          containerHeight,          
          experimentParams.containerPaddingPercentage
        );
        debugLog( "generatedpositions:", positions )
        let stimulusHTML = `<div style="width: 90vw; height: 90vh; background-color: #f0f0f0; position: relative; margin: auto; border-radius: 1px;">`;

        for (let i = 0; i < experimentParams.nTargs; i++) {
          const pos = positions[i];
          const rotation = Math.random() * 360;
          stimulusHTML += `<div class="search-item responsive" style="position: absolute;
           top: ${pos.y}%; left: ${pos.x}%; width: ${itemSize}px; height: ${itemSize}px;
            color: red; text-shadow: 0 0 3px white; font-weight: bold; transform: rotate(${rotation}deg);">X</div>`;
        }

        const targetPos = positions[experimentParams.nTargs];
        const targetRotation = Math.random() * 360;
        const targetColor = searchDifficulty === 1 ? 'blue' : 'red';
        const targetShape = searchDifficulty === 1 ? 'O' : 'T';

        stimulusHTML += `<div id="target" class="search-item search-target responsive" style="position: absolute;
         top: ${targetPos.y}%; left: ${targetPos.x}%; width: ${itemSize}px; height: ${itemSize}px;
          color: ${targetColor}; text-shadow: 0 0 3px white; font-weight: bold; cursor: pointer; transform: rotate(${targetRotation}deg);">${targetShape}</div>`;

        stimulusHTML += '</div>';
        return stimulusHTML;
      },
      choices: [],
      on_load: () => {
        const progressBar = document.createElement('div');
        progressBar.id = 'trial-progress-bar';
        progressBar.style.cssText = `
          position: absolute;
          bottom: 5vh;
          left: 10vw;
          width: 80vw;
          height: 20px;
          background-color: #ddd;
          border-radius: 10px;
          overflow: hidden;
        `;

        progressBar.innerHTML = `
          <div id="trial-progress-fill" 
              style="width: 100%; height: 100%; background-color: #4CAF50; transition: width 0.05s linear;">
          </div>`;
        document.body.appendChild(progressBar);

        const startTime = performance.now();
        const progressInterval = setInterval(() => {
          const elapsedTime = performance.now() - startTime;
          const remainingTime = Math.max(0, experimentParams.searchTrialDuration - elapsedTime);
          const progressPercent = (remainingTime / experimentParams.searchTrialDuration) * 100;
          document.getElementById('trial-progress-fill').style.width = `${progressPercent}%`;

          if (remainingTime <= 0) {
            clearInterval(progressInterval);
            document.body.removeChild(progressBar);
            jsPsych.finishTrial({ rt: null, is_correct: false });
          }
        }, 50);

        document.getElementById('target').addEventListener('click', () => {
          clearInterval(progressInterval);
          document.body.removeChild(progressBar);
          jsPsych.finishTrial({ rt: performance.now() - startTime, is_correct: true });
        });
      },
      on_finish: (data) => {        
        data.search_difficulty = searchDifficulty;
        data.enhanced = true;
        data.stimulus='VisSearch';
        data.task='VisSearch';

        experimentParams.dyn_VSD = searchDifficulty;
        
        if (!data.rt) {
          console.log('Timeout: No response.');
        } else if (!data.is_correct) {
          console.log('Incorrect response.');
        } else {
          console.log('Correct response in', data.rt, 'ms.');
        }
      },
    };
  }//end function

    // Modified digitSpanBackwardTask with dynamic length
    function createDigitSpanTask(currentSpan) {
      let digitsforCurrentTrial=[];
      return {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '',
        on_load: () => {
          const stimulusDiv = document.createElement('div');
          stimulusDiv.id = 'digit-span-stimulus';
          stimulusDiv.style.position = 'absolute';
          stimulusDiv.style.top = '50%';
          stimulusDiv.style.left = '50%';
          stimulusDiv.style.transform = 'translate(-50%, -50%)';
          stimulusDiv.style.fontSize = '15vw';
          stimulusDiv.style.fontWeight = 'bold';
          stimulusDiv.style.textAlign = 'center';
          document.body.appendChild(stimulusDiv);

          // Generate random sequence of digits
          digitsforCurrentTrial=[];
          for (let i = 0; i < currentSpan; i++) {
            digitsforCurrentTrial.push(Math.floor(Math.random() * 10));
          }
          
          // console.log('current digits:', digitsforCurrentTrial);

          let currentDigitIndex = 0;
          let timeoutId; // store the timeoutID for cleanup

          const showNextDigit = () => {
            stimulusDiv.innerHTML = '-';
            timeoutID = setTimeout(() => {
              if (currentDigitIndex < digitsforCurrentTrial.length) {
                stimulusDiv.innerHTML = digitsforCurrentTrial[currentDigitIndex];
                currentDigitIndex++;
                timeoutID = setTimeout(showNextDigit, experimentParams.digitDuration); //schedule next digit
              } else {
                stimulusDiv.innerHTML = '';
                cleanup(); //cleanup and finish trial
                jsPsych.finishTrial({
                  originalDigits: digitsforCurrentTrial,
                  currentSpanLength: currentSpan,
                });
              }
            }, 100);
          };
          const cleanup = () => {
            //clear any pending timeouts
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            //Remove the stimulus div from the DOM
            if (stimulusDiv && stimulusDiv.parentNode) {
              stimulusDiv.parentNode.removeChild(stimulusDiv);
            }
          }

          showNextDigit(); //start showing digits.
        },
        choices: [],
        on_finish: (data) => {
          if (data.originalDigits){
            // Create a copy of the array before reversing (to avoid mutating the original)
            const reversedDigits = [...data.originalDigits].reverse().join('');
            data.reversedDigits = reversedDigits;
            data.stimulus = `DSB`;
            data.task = `DSB ${data.originalDigits.join('')}`;
          } else {
            console.error('Original digits not found in trial data');
            data.reversedDigits = '';
            data.stimulus = `DSB error`;
            data.task = `DSB error`;
          }
        },

      };
    }

    
    function createRecallTask() {
      return {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
        <p>Please recall the digits in reverse order.</p>
        <div id="response-display" style="font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 20px; height: 30px;">
        <!-- Placeholder content with invisible text -->
        <span style="visibility: hidden;"> 0 </span>
        </div>       
        <div id="custom-button-container" style="text-align: center; margin-top: 20px;">
          ${[...Array(10).keys()]
            .map(
              (num) =>
                `<button class="digit-button" style="font-size: 24px; width: 40px; height: 40px; margin: 5px;" data-value="${num}">${num}</button>`
            )
            .join('')}
        </div>
        <div style="text-align: center; margin-top: 20px;">
          <button id="reset-button" style="font-size: 18px; padding: 8px 15px; margin-right: 10px;">Start Over</button>
          <button id="continue-button" style="font-size: 18px; padding: 8px 15px; display: none;">Continue</button>
        </div>`,
        choices: '',
        prompt: '<p>Click the numbers in the correct order.</p>',
        data: {
          task: 'DSBrecall'
        },
        on_load: () => {
          const lastTrial = jsPsych.data.get().last(1).values()[0];
          const reversedDigits = lastTrial.reversedDigits;
          const currentSpan = lastTrial.currentSpanLength;

          let userResponse = [];
          let clickedCount = 0;
          // RT tracking:
          let startTime= null;
          let endTime=null;

          const responseDisplay = document.getElementById('response-display');
          const continueButton = document.getElementById('continue-button');
          const resetButton = document.getElementById('reset-button');

          // Clear the placeholder content
          responseDisplay.innerHTML = '';

          // Function to update the response display
          const updateDisplay = () => {
            responseDisplay.textContent = userResponse.join(' ');

            // Show/hide the continue button based on response count
            if (clickedCount === currentSpan) {
              continueButton.style.display = 'inline-block';
            } else {
              continueButton.style.display = 'none';
            }
          };

          // Function to reset responses
          const resetResponses = () => {
            userResponse = [];
            clickedCount = 0;
            updateDisplay();
          };

          // Add click event for the reset button
          resetButton.addEventListener('click', resetResponses);

          // Add click event for the continue button
          continueButton.addEventListener('click', () => {
            endTime=performance.now();
            const rt= endTime-startTime;

            const userAnswer = userResponse.join('');
            const isCorrect = userAnswer === reversedDigits;

            // Count individual digit matches
            let correctDigits = 0;
            const expectedDigits = reversedDigits.split('');

            // Count correct digits in the right positions
            for (let i = 0; i < userResponse.length; i++) {
              if (userResponse[i] === expectedDigits[i]) {
                correctDigits++;
              }
            }

            jsPsych.finishTrial({
              is_correct: isCorrect,
              response: userAnswer,
              span_length: currentSpan,
              correct_digits: correctDigits,
              digit_accuracy: correctDigits / currentSpan,
              rt: rt,
            });
          });

          // Add click events for digit buttons
          const buttons = document.querySelectorAll('.digit-button');
          buttons.forEach((button) => {
            button.addEventListener('click', () => {
              if (clickedCount < currentSpan) {
                userResponse.push(button.dataset.value);
                clickedCount++;
                updateDisplay();
              }
            });
          });
        },
        on_finish: function (data) {
          data.stimulus = 'DSBrecall';
        }
      };
    }

    const customCalibration = {
        type: jsPsychHtmlButtonResponse,
        stimulus: function () {
          return `<div style= "font-size: ${24 * pixelsPerUnit / 150}px; color: white">              
                  <p>First, Please hold a credit card up to your screen.</p>
                  <p>Adjust this box until it matches the size of the credit card.</p>
                  <div id="calibration-box" style="
                      width: 506px;
                      height: 319px;
                      border: 2px solid white;
                      background-color: rgba(255,255,255,0.2);
                      margin: 20px auto;
                      resize: both;
                      overflow: hidden;
                  "></div>
              </div>
          `;
        },
        choices: ["Continue"],
        on_load: function () {
          console.log("Custom calibration loaded");
          // Store reference to the box in window scope
          window.calibrationBox = document.getElementById('calibration-box');
          // Add event listener to the button to capture dimensions right before click
          setTimeout(function () {
            const button = document.querySelector('button.jspsych-btn');
            if (button) {
              button.addEventListener('click', function () {
                if (window.calibrationBox) {
                  window.boxWidth = window.calibrationBox.offsetWidth;
                  console.log("Box width captured before click:", window.boxWidth);
                } else {
                  console.error("Box element not found at button click");
                }
              });
            }
          }, 100);
        },

        on_finish: function (data) {
          debugLog("on finish calibration running");
          // Use the width captured by the button click
          if (window.boxWidth) {
            pixelsPerUnit = Math.round(window.boxWidth / 3.375);
            console.log("Calibration complete, pixels per unit:", pixelsPerUnit);
            data.pixels_per_unit = pixelsPerUnit;
          } else {
            console.error("Box width not captured");
            data.pixels_per_unit = 150; // Default
          }
          data.stimulus='calibration';
          data.task='calibration';
        }
      };
  
        // function to shuffle the vis search difficulty across blocks (hold constant within).
        function getBalancedBetweenBlockConditions(numBlocks) {
            // Calculate how many of each condition we need
            const conditionsPerType = Math.floor(numBlocks / 2); // 2 conditions (vis search easy and hard)

            // Create an array with equal numbers of each condition
            let conditions = [];

            // Add condition 1 (conditionsPerType times)
            for (let i = 0; i < conditionsPerType; i++) {
                conditions.push(1);
            }

            // Add condition 2 (conditionsPerType times)
            for (let i = 0; i < conditionsPerType; i++) {
                conditions.push(2);
            }

            // If there are any remaining blocks due to division remainder
            const remaining = numBlocks - (conditionsPerType * 2);
            for (let i = 0; i < remaining; i++) {
                conditions.push(i + 1); // Add conditions 1, 2, etc. for remaining blocks
            }

            // Shuffle the array
            conditions = jsPsych.randomization.shuffle(conditions);

            return conditions;
        }
        // can call now (used in trial loop below);
        const searchperBlock= getBalancedBetweenBlockConditions(experimentParams.nBlocks);
        
        
        // Set up balanced conditions for a block, these are the image types within a block (1-3)
        function getBalancedWithinBlockConditions(numTrials) {
            // Calculate how many of each condition we need
            const conditionsPerType = Math.floor(numTrials / 3); // low medium and high images, and no.

            // Create an array with equal numbers of each condition
            let conditions = [];

            // Add condition 1 (conditionsPerType times)
            for (let i = 0; i < conditionsPerType; i++) {
                conditions.push(1);
            }

            // Add condition 2 (conditionsPerType times)
            for (let i = 0; i < conditionsPerType; i++) {
                conditions.push(2);
            }

            // Add condition 3 (conditionsPerType times)
            for (let i = 0; i < conditionsPerType; i++) {
                conditions.push(3);
            }

            //push a single no image condition
            conditions.push(0);
            
            // If there are any remaining trials due to division remainder
            const remaining = numTrials - (conditionsPerType * 3);
            for (let i = 0; i < remaining; i++) {
                conditions.push(i + 1); // Add conditions 1, 2, etc. for remaining trials
            }

            // Shuffle the array
            conditions = jsPsych.randomization.shuffle(conditions);

            return conditions;
        }

        //test: 
        const blockConditions = getBalancedWithinBlockConditions(experimentParams.nTrials);
        debugLog(blockConditions);

      // for help with data wrangling, create a function to consolidate data.
      
    function DSBsummarycalc(experimentParams, PreorPost) {
        // Filter recent recall data
        let recallData = jsPsych.data.get()
          .filter({ task: 'DSBrecall' })
          .last(1); // only get the last one, since we now only use Span ==8, else adjust as needed.

        // Calculate overall performance
        // let correctCount = recallData.filter({ is_correct: true }).count();
        // let totalCount = recallData.count();
        // let propCorrect = correctCount / totalCount;

        // Get all trials as array for easier processing
        const trial = recallData.values()[0];

        // Calculate digit-level accuracy
            const totalDigits = trial.span_length;  // Should be 8
            const totalCorrectDigits = trial.correct_digits;
            const digitAccuracy = totalDigits > 0 ? totalCorrectDigits / totalDigits : 0;

            // Determine if the response was completely correct
            const isCorrect = trial.is_correct;

            // Update dynamic fields based on PreorPost value
            if (PreorPost === 1) { // Pre-test
              experimentParams.dyn_DSBpre_propcorrect = isCorrect ? 1 : 0;
              experimentParams.dyn_DSBpre_maxspan = isCorrect ? totalDigits : 0;
              experimentParams.dyn_DSBpre_digitaccuracy = digitAccuracy;
              experimentParams.dyn_DSBpre_rt = trial.rt;

            } else if (PreorPost === 2) { // Post-test
              experimentParams.dyn_DSBpost_propcorrect = isCorrect ? 1 : 0;
              experimentParams.dyn_DSBpost_maxspan = isCorrect ? totalDigits : 0;
              experimentParams.dyn_DSBpost_digitaccuracy = digitAccuracy;
              experimentParams.dyn_DSBpost_rt = trial.rt;
            }

            // Log summary for debugging
            console.log(`DSB ${PreorPost === 1 ? 'Pre' : 'Post'} 
            Performance: - Completely correct: ${isCorrect ? 'Yes' : 'No'} - Max correct span: ${isCorrect ? totalDigits : 0} - Digit accuracy: ${(digitAccuracy * 100).toFixed(1)}%`);

            // Return updated experimentParams
            return experimentParams;
      }


    // the above function needs to be within a timeline variable to collect data during runtime.
      function addDSBCalculationToTimeline(timeline, experimentParams, preOrPost) {
        timeline.push({
          type: jsPsychHtmlKeyboardResponse,
          stimulus: '',
          choices: "NO_KEYS",
          trial_duration: 0,
          on_finish: function (data) {
            experimentParams = DSBsummarycalc(experimentParams, preOrPost);

            // Store the values in the data
            if (preOrPost === 1) {
              data.DSBpre_propcorrect = experimentParams.dyn_DSBpre_propcorrect;
              data.DSBpre_maxspan = experimentParams.dyn_DSBpre_maxspan;
              data.DSBpre_digitaccuracy = experimentParams.dyn_DSBpre_digitaccuracy;
              data.DSBpre_rt = experimentParams.dyn_DSBpre_rt;
            } else {
              data.DSBpost_propcorrect = experimentParams.dyn_DSBpost_propcorrect;
              data.DSBpost_maxspan = experimentParams.dyn_DSBpost_maxspan;
              data.DSBpost_digitaccuracy = experimentParams.dyn_DSBpost_digitaccuracy;
              data.DSBpost_rt = experimentParams.dyn_DSBpost_rt;
            }
            data.trial_type = "dsb-summary-calculation";
          }
        });
      }

      //addVSearchCalculationToTimeline, similar to above, but to update vis search DVs.
      function addVSearchCalculationToTimeline(timeline, experimentParams) {
        timeline.push({
          type: jsPsychHtmlKeyboardResponse,
          stimulus: '',
          choices: "NO_KEYS",
          trial_duration: 0,
          on_finish: function (data) {
            data.trial_Type= 'vissearch-summary-calculation';
            
            let visData = jsPsych.data.get()
              .filter({ task: 'VisSearch' })
              .last(experimentParams.nRepeats);

            // Calculate overall performance  
            let correctCount = visData.filter({ is_correct: true }).count();
            let totalCount = visData.count();
            let propCorrect = correctCount / totalCount;

            // Get all RT values (excluding null values)
            let allTrials = visData.values();
            let validRTs= [];
            // Extract non-null RT values
            for (let i = 0; i < allTrials.length; i++) {
              if (allTrials[i].rt !== null && allTrials[i].rt !== undefined) {
                validRTs.push(allTrials[i].rt);
              }
            }

            // Calculate mean RT if there are valid RT values
            let meanRT = 0;
            if (validRTs.length > 0) {
              let sum= validRTs.reduce((a,b)=>a+b,0); //avoids for loop.
              //reduce() applies a function to each element in the array, accumulating a result
              // (a, b) => a + b is an arrow function where:
              // a is the accumulator (running total)
              // b is the current element being processed
              // 0 is the initial value of the accumulator

              meanRT = sum / validRTs.length;
            }
            data.VISsearch_propcorrect = propCorrect;
            data.VISsearch_meanRT= meanRT;
            // Update experimentParams for later access
            experimentParams.dyn_VS_propcorrect = propCorrect;
            experimentParams.dyn_VS_meanRT = meanRT;
      
            console.log(`Visual Search Performance: 
            - Proportion correct: ${(propCorrect * 100).toFixed(1)}% (${correctCount}/${totalCount})
            - Mean RT: ${meanRT.toFixed(2)} ms`);
          }
      });
    }


// Usage:
// addDSBCalculationToTimeline(timeline, experimentParams, 1); // For pre-test
// ... other trials ...
// addDSBCalculationToTimeline(timeline, experimentParams, 2); // For post-test


      function consolidateTrialData() {
          return {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '',
            choices: "NO_KEYS",
            trial_duration: 0,
            on_finish: function(data) { //on_finish is crucial so it is called during run time.
              // Pre-populate all values
              data.block=  experimentParams.dyn_block;
              data.trial= experimentParams.dyn_trial;
              data.trialid= experimentParams.dyn_trialidx;
              data.VisDifficulty =experimentParams.dyn_VSD;
              data.Vis_meanRT = experimentParams.dyn_VS_meanRT;
              data.Vis_propCorr= experimentParams.dyn_VS_propcorrect;
              data.DSBpre_propcorrect= experimentParams.dyn_DSBpre_propcorrect;
              data.DSBpre_maxspan= experimentParams.dyn_DSBpre_maxspan;
              data.DSBpre_digitaccuracy= experimentParams.dyn_DSBpre_digitaccuracy;
              data.DSBpost_propcorrect= experimentParams.dyn_DSBpost_propcorrect;
              data.DSBpost_maxspan= experimentParams.dyn_DSBpost_maxspan;
              data.DSBpost_digitaccuracy= experimentParams.dyn_DSBpost_digitaccuracy;
              data.imageIDX= experimentParams.dyn_imageID; 
               // Add vegetation level and image type information based on imageIDX
              const imgID = experimentParams.dyn_imageID;

              // Only process for images 1-9, not for fixation cross (10)
              if (imgID >= 1 && imgID <= 9) {
                // Determine vegetation level
                if (imgID === 1 || imgID === 4 || imgID === 7) {
                  data.vegetationLevel = 1; // Low
                } else if (imgID === 2 || imgID === 5 || imgID === 8) {
                  data.vegetationLevel = 2; // Medium
                } else if (imgID === 3 || imgID === 6 || imgID === 9) {
                  data.vegetationLevel = 3; // High
                }

                // Determine image type
                if (imgID === 1 || imgID === 5 || imgID === 9) {
                  data.imageType = 1; // Real
                } else {
                  data.imageType = 2; // AI
                }
              } else {
                // For the fixation cross or any other cases
                data.vegetationLevel = null;
                data.imageType = null;
              }
              data.trial_type=  "consolidated-trial-data";
              data.stimulus =   "consolidated-trial-data";
              data.task =   "consolidated-trial-data";
            }
          };
        }
      /////////////// CREATE THE TIMELINE
      // Enhanced timeline generator (with counterbalancing?)

    
      const timeline = [];

     
      // Add preload
      timeline.push(preloadImages);
      
      timeline.push(messages.Welcome);
      timeline.push(messages.PISdoc);  
      timeline.push(demographicsForm);
        
      //prac Instructions
      timeline.push(messages.pracInstructions);
      timeline.push(customCalibration);

      // practice trials have a unique structure (no images):
      
      for (let i = 0; i < experimentParams.nPracticeTrials; i++) {
        // Practice visual search
        //add instructions for the visual search task. 
        timeline.push(messages.VisSearchInstructions);

        // show nRepeats of fixed difficulty. alternate based on nPracticetrials:
        const currentDifficulty = (i%2 ===0)? 1:2;        
          //push to timeline.
          for (let irep = 0; irep < experimentParams.nRepeats; irep++) {
            timeline.push(createVisualSearchTrial(currentDifficulty)); // 1 of 2 difficulties.)
          }

        // add instructions for the DSB task
        timeline.push(messages.DSBinstructions);
        timeline.push(createDigitSpanTask(4)); //start easy.
        timeline.push(createRecallTask());
        timeline.push(feedbackTrial); // note no feedback in exp proper.

        timeline.push(messages.DSBinstructions);
        timeline.push(createDigitSpanTask(experimentParams.maxDigitSpan)); // actual span.
        timeline.push(createRecallTask());
        timeline.push(feedbackTrial); // note no feedback in exp proper.

        //DSB (*)min to max span)
        // for (let iSpan = experimentParams.minDigitSpan; iSpan < experimentParams.maxDigitSpan; iSpan++) {
          // timeline.push(messages.DSBinstructions);
          // timeline.push(createDigitSpanTask(iSpan));
          // timeline.push(createRecallTask());
          // timeline.push(feedbackTrial); // note no feedback in exp proper.
        // }

      } //for practice trials

      // now include end of practice msg
      timeline.push(messages.expInstructions);
      
      // populate main experimental trials.
      
      let trialidx=-1; // counter
      
      for (let iblock = 0; iblock < experimentParams.nBlocks; iblock++) {

        // work out the image type for each trial in this block:
        let imgindex = [1,2,3,4,5,6,7,8,9,10];
        imgindex= jsPsych.randomization.shuffle(imgindex);

        // const blockConditions = getBalancedWithinBlockConditions(experimentParams.nTrials);

        let currentDifficulty = searchperBlock[iblock]; // 1 or 2, shown for nRepeats below (pre DSB1)

        for (let itrial = 0; itrial < experimentParams.nTrials+1; itrial++) { // +1 to include the last trial (no image)
          
          trialidx=trialidx+1;
          // for each trial sequence (ntrials per block)

          // Randomly add attention check
          if (Math.random() < experimentParams.attentionCheckFrequency) {
            timeline.push(createAttentionCheck());
          }
          // // push message showing progress:   
          const trialStart = {
                type: jsPsychHtmlButtonResponse,
                stimulus: `<div class="experiment-text" style= "font-size: ${48 * pixelsPerUnit / 150}px;">
                    <p> Get ready to start Trial ${itrial+1} of ${experimentParams.nTrials+1}, <br> <br>
                        Block : ${iblock + 1} of ${experimentParams.nBlocks} </p>`,                    
                choices: ['Start'],                
                button_html: '<button style="font-size: 20px; padding: 15px 30px; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000;">%choice%</button>',
                on_finish: function (data) {
                    //replace stim with simple placeholder
                    data.stimulus = `block message`;
                    //update at run time for data wrangling:
                    experimentParams.dyn_block = iblock;
                    experimentParams.dyn_trial = itrial;
                    experimentParams.dyn_trialidx = trialidx;
                }
            };

            // push block message.
            timeline.push(trialStart);

          // add trial sequence. 
          // order is currently fixed too:
          // -  vis search (easy or hard), with nRepeats
          // -  DSB, (now just 8 - fixed)
          // - image
          // - DSB recall 

          //Vis search
          // instructions:
          timeline.push(messages.VisSearchInstructions)
          
          //push to timeline.
          for (let irep = 0; irep < experimentParams.nRepeats; irep++) {
            timeline.push(createVisualSearchTrial(currentDifficulty)); // 1 of 2 difficulties.)
          }
          addVSearchCalculationToTimeline(timeline,experimentParams);
          //DSB (pre) sequence:
          timeline.push(messages.DSBinstructions);
          timeline.push(createDigitSpanTask(experimentParams.maxDigitSpan));
          timeline.push(createRecallTask());
          
          // for (let iSpan = 0; iSpan < experimentParams.DSBconds.length; iSpan++) {
          //   timeline.push(createDigitSpanTask(experimentParams.DSBconds[iSpan]));
          //   timeline.push(createRecallTask());
          // }
          
          addDSBCalculationToTimeline(timeline, experimentParams, 1); // For pre-test
          
          
          // show image.
          let im2show = imgindex[itrial];
          timeline.push(messages.imageInstructions);
          timeline.push(callSingleImageTrial(im2show));


          //DSB (post)
          timeline.push(messages.DSBinstructions);
          timeline.push(createDigitSpanTask(experimentParams.maxDigitSpan));
          timeline.push(createRecallTask());

          // timeline.push(messages.DSBinstructions);
          
          // for (let iSpan = 0; iSpan < experimentParams.DSBconds.length; iSpan++) {
          //   timeline.push(createDigitSpanTask(experimentParams.DSBconds[iSpan]));
          //   timeline.push(createRecallTask());
          // }

          //get data for these last few trials:
          addDSBCalculationToTimeline(timeline, experimentParams, 2); // For post-test
          
          timeline.push(consolidateTrialData());        
          
        }

      } // for block

    // collect ratings of restorativeness per image:
    timeline.push(PRSpreamble);
      for (let imgn = 1; imgn < 10; imgn++) {
        timeline.push(createPRS11(imgn));
      }      
      // important to ask about AI AFTER the restorativeness ratings.
      
      for (let imgn = 1; imgn < 10; imgn++) {
        timeline.push(createRateAIlikelihood(imgn,1));
      }      
      
      timeline.push(messages.Debriefdoc); 
    
      jsPsych.run(timeline);//

    


  </script>
</body>

</html>